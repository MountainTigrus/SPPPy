# Руководство пользователя к библиотеке SPPPy

# I. Введение
## 1. О библиотеке
SPPPy - библиотека на Python для моделирования коэффициентов отражения при возбуждении поверхностных плазмон-поляритонов (ППП) в случае призменного ввода ППП по схеме Кречманна-Райтера или Отто. 

<img src=https://i.imgur.com/fp2bC6z.png width="100%">

<ins>**Рис 1.** структуры многослойной модели: схема Кречманна-Райтера (а) и схема Отто (б).</ins>

В настоящий момент в библиотеке реализован матричный подход для вычислений многослойных структур для p и s - поляризованного излучения. Для каждой границы слоя рассчитывается матрица переноса, связывающая световые потоки до границы и после. Далее матрицы, соответствующие каждой границе, перемножаются и в результате мы получаем связь потоков до всей схемы - на входе - и после неё - на выходе. Из  полученной зависимости и определяется коэффициент отражения.  

В структуре из N слоёв считается, что слой *0* это призма, в которой задан угол падения ${\theta}$. Призма и последний слой *N-1* полубесконечные, остальные слои имеют свою определённую толщину, причём их толщина много меньше длины когерентности излучения, поэтому мы учитываем фазовый множитель при распространении световой волны.

Для работы со слоями в библиотеке есть следующие функции:
- добавление слоя,
- удаление слоя,
- добавление промежуточного слоя,
- замена слоя.

Работать можно со слоями следующих типов:
- диэлектрик,
- металл,
- градиентный слой (коэффициент преломления зависит от глубины),
- анизотропный слой, плоскость необыкновенного преломления которой совпадает с плоскостью падения,
- материал с дисперсией.

В библиотеке реализовано получение зависимости коэффициента отражения по интенсивности - **R** (вещественный) и по амплитуде электрического поля **r** (мнимый, с учётом изменения фазы) для построенной пользователем схемы. Зависимость можно строить от диапазона углов падения *${\theta}$* (передаётся в библиотеку в градусах)  с фиксированной длиной волны *${\lambda}$* (в метрах) и от диапазона *${\lambda}$* с фиксированным углом *${\theta}$*.

Толщины и длины волн указываются в метрах, углы - в градусах.





## 2. Установка
Для установки нужно скачать файлы библиотеки по следующей ссылке:
https://disk.yandex.ru/client/disk/THz%20lab/%D0%90%D0%BD%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D0%B2/SPPPy

Там должны находиться следующие файлы:
- \_\_init__.py - системный файл, благодаря которому проект виден как одна библиотека;
- SPPPy2.py - файл с основным классом ExperimentSPR;
- SuPPPort.py - файл с дополнительными типами слоёв и вспомогательными процедурами;
- PermittivitiesBase.csv - база данных материалов с дисперсией.
- Readme.md - копия данного мануала (необязательно); 
- .gitignore -  файл для git, исключающий для загрузки в сеть все файлы, кроме библиотеки (необязательно).
- PermittivitiesBase SAVED.csv - копия базы данных материалов на случай повреждения или уничтожения пользователем базы (необязательно).

Далее кладём скачанные файлы в папку *SPPPy*, перемещаем полученную папку в папку с Вашим проектом и работаем!

Так-же все файлы выложены на самом github: https://github.com/MountainTigrus/SPPPy





# II. Создание схемы эксперимента
## 1. Работа со слоями.

Для работы нам нужно создать простую схему - экземпляр класса **SPPPy.ExperimentSPR()**.

```python
from SPPPy import *

Unit = ExperimentSPR()
```
По умолчанию считается, что в эксперименте излучение будет иметь поляризацию *p*. Если нужно использовать поляризацию *s*, то в конструктор передаётся параметр **polarisation**:
```python
Unit = ExperimentSPR(polarisation='s')
```
Нас здесь это не интересует, так как плазмон-поляритоны возбуждаются только при *p* поляризации.

Схема, которая теперь будет строиться хранится в словаре **Unit.layers**, который в данный момент пустой. Ключами для словаря являются номера слоёв, начинающихся с нуля. Добавим нулевой слой, который соответственно будет нашей призмой. Для этого воспользуемся процедурой **add**:
```python
Unit.add(Layer(1.23, 0))
```

Каждый слой моделируется классом **SPPPy.Layer(n, thickness, name=None)**, конструктор которого принимает следующие параметры: коэффициент преломления **n** и толщину **thickness**. Необязательный параметр **name** служит для сохранения справочной информации о данном слое.  

Теперь у нас в схеме есть один слой. Последовательно добавим ещё слои в схему:

```python
Unit.add(Layer(0.05 + 4.24j, 55e-9))
Unit.add(Layer(1, 100))
```

Комплексные значения **n** (0.05 + 4.24j) соответствует слою металла, вещественные - диэлектрика.

В результате у нас есть схема из трёх слоёв с которой мы и будем моделировать эксперименты. Чтобы посмотреть информацию по созданной нами схеме можно вызвать процедуру **Unit.show_info()**. Вызвав её мы увидим:

```
 --- Unit parametrs ---
k0: 6283185.307179587
λ:  1e-06
n:  [1.23, (0.05+4.24j), 1]
d:  [0, 5.5e-08, 0]
No gradient layers found.
```
Стоит подчеркнуть, что первый и последний слой полубесконечные, поэтому при расчётах их толщина считается равной нулю, вне зависимости от того, чему равен параметр **thickness** в данных экземплярах класса. Можно было заметить, что в последнем слое мы указали толщину 100, что привело бы к бессмысленности схемы из-за таких огромных расстояний (100 метров!), но это внешний слой, поэтому эта цифра не имеет смысла.

В целом для управления слоями в настоящий момент имеются следующие процедуры:
- **Unit.add(SPPPy.Layer)** - добавление нового слоя в конец схемы,
- **Unit.delete(num)** - удалить слой с порядковым номером num,
- **Unit.insert(num, SPPPy.Layer)** - добавление экземпляра класса SPPPy.Layer на место *num*,
- для замены слоя просто меняем значение в словаре **Unit.layers**, например:
```python
Unit.layers[1] = Layer(0.1 + 16.3j, 15e-9)
```
Здесь слой с номером *1* заменяется на новый.

Кроме того, мы можем вручную менять параметры слоёв через внутренние параметры класса, например:
```python
Unit.layers[2].thickness = 14e-9
```
То есть мы просто в словаре **layers** взяли слой *2*, который является классом SPPPy.Layers, и поменяли его параметр **thickness**.





## 2. Моделирование эксперимента.

Для моделирования эксперимента в схеме есть следующие параметры: длина волны **Unit.wavelength** и угловая частота, нормированная на скорость света, **Unit.k0**, которые связаны следующим уравнением:

$$ k_0=\frac{2 \pi}{\lambda}$$

По умолчанию длина волны равна $10^{-6}$. При изменении длины волны угловая частота рассчитывается автоматически и обратно. То есть, например, при изменении
```python
Unit.wavelength = 632*e-9
```
**Unit.k0** будет пересчитано по формуле.

Теперь наша схема полностью готова и мы можем получить зависимости коэффициентов отражения от угла или длины волны. Для этого используется процедура **Unit.R(angles=None, wavelenghts=None, angle=None, is_complex=false)**. Рассмотрим как она работает:
- чтобы получить массив коэффициентов отражения для диапазона углов, передаём массив со значениями углов в параметр **angles**, остальные не трогаем;
- если же нас интересует коэффициент отражения в диапазоне длин волн, мы передаём этот диапазон в **wavelenghts** и угол, на котором смотрим отражение, в **angle**.

По умолчанию коэфициенты отражения выдаются по энергии (вещественные), если нас интересует, как меняется фаза колебаний электрического поля, то флаг **is_complex** устанавливается в *True*, и в результате выполнения процедуры мы получим комплексный коэффициент отражения r, связанный с вещественным R следующим соотношением:

$$ R=|r|^2$$

Данная процедура содержит в себе несколько технических процедур, которые также могут иногда быть полезны:
- **Unit.R_theta_re(degree_range)** - вещественный коэффициент отражения (по энергии) в указанном диапазопе углов
- **Unit.R_theta_cmpl(degree_range)** - комплексный коэффициент отражения (по интенсивности со сдвигом фазы) в указанном диапазопе углов
- **Unit.R_lambda_re(angle_grad, lambda_range)** - коэффициент отражения (по энергии) на угле **angle_grad**, данным в градусах в указанном диапазоне длин волн
- **Unit.R_lambda_cmpl(angle_grad, lambda_range)** - комплексный коэффициент отражения (по интенсивности со сдвигом фазы) на угле **angle_grad**, данным в градусах в указанном диапазоне длин волн

Все эти процедуры в свою очередь работают через **Unit.R_deg(theta)**, которая выдаёт комплексный коэффициент отражения по амплитуде для актуальной схемы на угле *theta*. С помощью этой процедуры можно придумывать свои последовательности изменения параметров.

Теперь, когда мы знаем всё необходимое, построим для примера вещественный коэффициент отражения для диапазона углов:
```python
# зададим диапазон углов с нужным нам разрешением
degree_range = np.linspace(54, 58, 200)
# Получим массив коэффициентов отражения для выбранного диапазона
data = Unit.R(angles=degree_range)
```

Теперь мы можем построить график сами, либо воспользоваться встроенной процедурой:

```python
plot_graph(x, y, name='reflection_dataection', tir_ang=None, label=None,
               dpi=None, ox_label='ϴ', oy_label='R', oy_limits=True):
```

где **x** и **y** - набор точек для графика, **name** *(необязательно)* - подпись графика (если её не указывать, то название будет 'Reflection'),**tir_ang** *(необязательно)* - угол полного внутреннего отражения для (можно получить через процедуру **Unit.TIR()** или задать вручную), **label** (необязательно) - подпись на графике и **dpi** *(необязательно)* - качество изображения, ox_label - название оси **x**, **oy_label** *(необязательно)* - название оси **y**. Флаг **oy_limits** *(не обязательный)* фиксирует максимальное значение по оси **y** в точку 1.05 и минимальное в точку 0. Если он установлен в положение *False*, то верхняя и нижняя гарница выбирается автоматически по значениям.

Также для вывода графиков комплексного коэффициента отражения есть процедура
```python
def plot_graph_complex(R_array, name='Reflection_data', fix_limits=False, dpi=None,):
```
Здесь R_array - массив комплексных значений коэффициентов отражения, **name** *(необязательно)* - подпись графика (если её не указывать, то название будет 'Reflection_data''), **dpi** *(необязательно)* - качество изображения. Флаг **oy_limits** *(не обязательный)* фиксирует минимальные значения вещественной и комплексной части между 0 и 1.05. Если он установлен в положение *False*, то верхние и нижние гарницы выбираются автоматически по значениям.





## 3. Итоговая программа по моделированию.

Итак, мы разобрали основные процедуры, необходимые для построения схемы и моделирования эксперимента! В результате наша программа выглядит следующим образом:
```python
from SPPPy import *

Unit = ExperimentSPR()

# Создаём схему
Unit.add(Layer(1.23, 1))
Unit.add(Layer(0.05 + 4.24j, 55e-9))
Unit.add(Layer(1, 100))

Unit.wavelength = 632e-9

# Смотрим информацию о получившейся схеме
Unit.show_info()

# Моделируем эксперимент
degree_range = np.linspace(54, 58, 200)
data = Unit.R(angles=degree_range)

# Строим график зависимости
plot_graph(degree_range, data, tir_ang=Unit.TIR(),  dpi=300)
```

<img src=https://i.imgur.com/RsnE23m.png height="400">

<ins>**Рис 2.** Зависимость коэфициента отражения для диапазона углов в возданной схеме.</ins>





#  III. Дополнительные типы слоёв
## 1. Градиентный слой.
Кроме диэлектриков с вещественным **n** и металлов c комплексным коэффициентом преломления **n + i$\times$k** (показатель преломления и коэффициент затухания) есть ещё несколько более сложных типов слоёв. В первую очередь рассмотрим градиентный слой. Показатель преломления данного слоя меняется от глубины слоя и  задаётся с помощью лямбда-функции: 

```python
Unit.add(Layer(lambda x: 1.3 - 0.2*x, 1e-9, name="Градиентный слой"))
```

Значение лямбда функции F(d) хранится в параметре **n** класса **Layer**, что можно использовать для доступа к самой лямбда-функции. Для градиентного слоя с порядковым номером *i* значение функции берётся в диапазоне от *0* до *1*, где F(0) расположено возле слоя *i-1*, F(1) - возле слоя *i+1*.  Чтобы посмотреть профили всех градиентных слоёв в системе можно использовать следующую процедуру:
```python
Unit.gradient_profiles(dpi=200)
```
которая нарисует профили всех градиентных слоёв в одном графике с качеством картинки, указанным в параметре dpi, который является необязательным. Если параметр **name** слоя задан, то в заглавии графика будет его значение, иначе будет надпись: "Gradient profile in layer #" и указан номер слоя. В нашем случае мы получим следующий график:
<img src=https://i.imgur.com/0tmPKX4.png height="400">
<ins>**Рис 3.** Пример профиля градиентного слоя.</ins>
Кроме того, при вызове известной нам процедуры **Unit.show_info()** также будут выведены графики всех градиентных слоёв при наличии. Что бы получить только информацию без гарфиков следует в ней указать **show_profiles**=*False*:
```python
Unit.show_info(show_profiles=False)
```

Для расчётов матрицы переноса градиентного слоя программа делит этот слой на 100 однородных слоёв одинаковой толщины, у которых **n** зависит от глубины слоя: F(0) у первого слоя, F(i/100) у i-го слоя и F(1) у последнего. Очевидно, что чем больше количество слоёв, на которые мы делим этот слой тем точнее будут измерения, но тем дольше будет работать программа. Количество сублоёв на которое происходит разбиение можно менять, для этого передаём в параметр **ExperimentSPR.gradient_resolution** нужное нам значение, например:
```python
Unit.gradient_resolution=30
```
Теперь градиентный слой будет делиться при расчётах на 30 однородных слоёв. Как показывает практика разбиение градиентного слоя более чем на 100 субслоёв не даёт значительных поправок, но 100 слоёв даёт хорошую точность вычислений.






## 2. Анизотропный слой.
Класс **Anisotropic** создан для добавления анизотропного слоя, плоскость необычного преломления которого находится в плоскости падения света. Сам анизотропный слой обладает обыкновенным коэффициентом преломления **n0**, если световой поток идёт под некоторым углом ${\theta}_{main}$, и необыкновенным **n1** в ортогональном направлении. Таким образом для каждого угла падения данный слой будет иметь свой показатель преломления. Чтобы добавить в схему анизотропный слой, необходимо написать процедуру:
```python
Unit.add(Layer(Anisotropic(n0=1.2, n1=1.1, anisotropic_angle=10), 1e-9))
```
В данном слое ось анизотропии будет направлена под углом 10 градусов с нормали, значит обыкновенный коэффициент преломления **n0** будет чувствовать световая волна, падающая под этим углом. По умолчанию данные параметры установлены следующим образом: **n0** = *1*, **n1** = *1*, **anisotropic_angle** = *0*, следовательно при иницйиализации один или несколько параметров можно не указывать. если нас устраивают эти значения. В параметре **n** класса **Layer** теперь хранится экземпляр класса **SPPPy.Anisotropic**.

## 3. Материал модели Друде-Лоренца
Класс **LorentzDrude** создан для добавления вещества, комплексный показатель преломления которого вычисляется через формулу Друде-Лоренца:

\begin{equation}
\hat{n}(\omega) = \tilde\varepsilon(\omega)^2 = \left( \varepsilon_\infty + \sum_{j}\frac{f_i \omega_{pj}^2}{\omega_{0j}^2 - \omega^2 - i\omega_{tj}\omega} \right)^2
\end{equation}

Инициализация класса включает в себя следующие параметры:
```python
material = LorentzDrude(wp, wt, w0=0, amplitude=1, eps_inf=1, name=None)
```
Здесь параметр **wp** - плазменная частота, **wt** - время релаксации электронов в металле, **w0** *(необязательно)* - частота колебания связанных электронов в диэлектрике (в случае валентных электронов **w0**=0, как и _установлено по умолчанию_), **amplitude** *(необязательно)* - амплитуда осциллятора, **eps_inf** *(необязательно)*  - параметр диэлектрической проницаемости при частоте, стремящейся к бесконечности (_по умолчанию установлено 1_), **name** *(необязательно)* - название вещества данного слоя, либо дополнительная информация. Если есть простое вещество в котором все электроны имеют одинаковые связи, например, все электроны считаются электронами проводимости или валентными электронами с одинаковой энергией связи с ядром, то параметры **wp**, **wt**, **w0** и **amplitude** предаставляют собой переменные типа *float*. Если в веществе есть несколлько групп электронов с разными связями, то в процедуру нужно передавать массивы одинаковой длины.
**(!) Все частоты в данный класс необходимо передавать в герцах (!)**

Используя данный класс можем получить значение **n** и **k** вещества, передав в процедуру **LorentzDrude.CRI(wavelength)** интересующую нас длину волны. 

Также можно посмотреть график **n** и **k** указанного вещества:
```python
material = LorentzDrude(wp=[0.57e14, 3.38e13], wt=[1.94e12, 0.84e12],
                            w0=[0, 3.38e13], eps_inf = 2, name="InSb")

wl_range = np.linspace(10, 200, 1000)*1e-6
material.show_CRI(wl_range, dpi=100)

```
Здесь **dpi** - качество изображения.
<img src=https://i.imgur.com/QaNJJ5n.png height="400">
<ins>**Рис 4.** Зависимость комплексного коэффициента преломления для антимонида индия в модели Друде-Лоренца.</ins>

Кроме того, можно воспользоваться дополнительной процедурой: **show_CRI_permittivity(self, lambda_range, dpi=None)**, которая нарисует диэлектрическую проницаемость данного вещества, но диапазон длин волн преобразует в частоту.

В ходе работы программы параметры экземпляра класса можно изменять, например:
```python=
material.wp = 0.3e15
```
Однако, если в примере сверху в исходном случае было несколько слоёв, а мы вместо массива пославили одно значение типа _float_, то при присвоении значения переменной программа выдаст ошибку. И обратно, если был один тип электронов, а мы вписали массив, то программа работать не будет.





## 4. Слой с дисперсией по длине волны.
Класс **MaterialDispersion** создан для добавления веществ с дисперсией коэффициента преломления по длине волны. Добавим такой слой:
```python
Unit.add(Layer(MaterialDispersion("Au"), 1e-9))
```
Теперь мы можем получить значение **n** и **k** золота (Au), передав в процедуру **MaterialDispersion.CRI(wavelength)** интересующую нас длину волны. Однако стоит быть осторожным - для каждого материала есть область определения, если выйти за неё, то процедура выдаст значение для ближайшей длины волны, для которой известно значение, и выведет информацию об ошибке в консоль. Проверить доступные материалы и диапазоны длин волн, в которых можно получить их значение, можно через процедуру **MaterialDispersion.Metals_List()**. Например:
```python
Material = MaterialDispersion("Au")
Material.Metals_List()
```
Мы получим примерно следующий вывод:
```
        Wavelength         
               min      max
Element                    
Ag        0.187900    1.937
Al        0.000124  177.120
Au        0.187900    1.937
Be        0.247970   61.992
Li        0.326000    2.066
```
В уже созданном экземпляре класса можно узнать границы области определения через параметры **MaterialDispersion.min_lam** и **MaterialDispersion.max_lam**. Однако стоит быть осторожным - если данные параметры изменить это может привести к ошибкам!

Также мы можем посмотреть график **n** и **k** указанного вещества:
```python
wl_range = np.linspace(0.2, 3)*1e-6
Material.show_CRI(wl_range)
```
 Процедура выведет график для всех допустимых длин волн:
<img src=https://i.imgur.com/c76Qyoq.png height="400">
<ins>**Рис 5.** Зависимость комплексного коэффициента преломления для золота.</ins>

Параметр **wl_range** является необязательным - без него процедура выведет график для всей области определения. Если же мы передадим диапазон, границы которого выходят за область определения, процедура просто удалит все точки, не попавшие в неё. Если все переданные точки не попадут в область определения, то этот параметр будет игнорироваться и процедура снова выведет график для всей области определения.





## 5. Работа с базой веществ через MaterialDispersion.
При создании класса **MaterialDispersion** можно использовать дополнительные базы материалов. Для этого при создании экземпляра класса указываем файл в формате .csv в конструкторе.
```python
Material = MaterialDispersion("Au", base_file="MyFile.csv")
```
После этого для изменения списков веществ мы можем воспользоваться процедурами удаления, добавления и слияния двух веществ, встроенные в класс **MaterialDispersion**. Данными процедурами можно менять также исходный файл, но делать это не рекомендуется (если не создана его резервная копия) - иначе можно просто потерять ВСЕ данные!

Давайте рассмотрим процедуры работы с базой данных. 

**а)** Процедура **add_material(element, material_file)** добавляет новый элемент с именем *element*, если данное имя не занято в базе (иначе процедура просто выведет ошибку), из файла *material_file*, загруженного с сайта *https://refractiveindex.info*. Такой файл можно создать самому, выглядит он следующим образом. Первая строка: *"Wavelength, µm","n","k"* (которая на самом деле обрезается при загрузке и не имеет значения). В следующих строках указываются по три значения, соответствующие длине волны в микрометрах, коэффициенту преломления **n** и коэффициенту затухания **k** соответственно, где в качестве как десятичного разделителя так и разделителя ячеек используется запятая. Например: *0,1879,1,28,1,188*. Здесь *0,1879* - длина волны, *1,28* - **n**, *1,88* - **k**. С сайта часто загружаются файлы, где в строке указаны 5, а не 6 значений, идущих через запятые. Такие строки следует удалить. При попытке загрузки файла с подобными ошибками интерпретатор Python укажет номера таких строк.

**б)** Процедура **delete_material(material)** просто удаляет материал, имя которого передано в строковом значении *material* из базы.

**в)** Слияние двух элементов с помощью процедуры **merge_materials("Al", second, new_name, delete_origin=True)**. Процедура ищет материалы с именами *primary* и  *second* и сливает их в новый материал с названием *new_name*. Причём процедура берёт ВСЕ точки материала *primary* и добавит в неё точки материала *second*, которые не входят в зону определения первой, то есть часть с пересечением зоны определения отсекается от второго вещества. Если вещество с названием *new_name* уже есть, то процедура выдаст ошибку. Флаг **delete_origin** показывает надо ли удалять исходные вещества данные при создании нового или же их следует оставить. По умолчанию он установлен в значение *True*.
Таким образом процедура:
```python
merge_materials("Alum", "Al2" , "Aluminium")
```
Создаст новый материал "Aluminium" и удалит из бызы материалы "Alum" и "Al2". Если же нам ещё пригодятся "Alum" и "Al2" и мы не хотим удалять, то добавляем флаг **delete_origin**=*False*.

Также, если **delete_origin** установлен в положение *True*, то именем нового материала может быть имя одного из исходных веществ. Например, слияние "Al2" + "Al" → "Al" пройдёт только если исходные данные удаляются, иначе процедура выдаст ошибку.
При сливании баз следует быть осторожным, так как разные базы могут иметь значения показателей, измеренных в разных условиях, поэтому при слиянии могут образоваться перепады:
 <img src=https://i.imgur.com/xzTsNI4.png height="400">
<ins>**Рис 5.** Пример скачка параматров при неудачном слиянии баз.</ins>

Это не реальное вещество, на самом деле скачки будут намного меньше, но внесут нелинейности в Вашу систему.
